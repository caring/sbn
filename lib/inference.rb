class Sbn
  class Net
  	# Returns a hash containing the estimated posterior probability of each
    # possible state for the specified node, based on previously-supplied
    # evidence, using the Markov Chain Monte Carlo algorithm. The MCMC algorithm
    # generates each event by making a random change to the preceding event. The
    # next state is generated by randomly sampling a value for one of the
    # nonevidence variables Xi, conditioned on the current values of the
    # variables in the Markov blanket of Xi. MCMC basically wanders randomly
    # around the state space--the space of possible complete
    # assignments--flipping one variable at a time, but keeping the evidence
    # variables fixed. The sampling process works because it settles into a
    # "dynamic equilibrium" in which the long-run fraction of time spent in each
    # state is proportional to its posterior probability.
    def query_node(nodename)
      state_frequencies = {}
      e = generate_random_event
      relevant_e = relevant_evidence(nodename, e)
      MCMC_NUM_SAMPLES.times do
        state = e[nodename]
        state_frequencies[state] ||= 0
        state_frequencies[state] += 1

        relevant_e.each do |nname, nstate|
          e[nname] = @nodes[nname].get_random_state_with_markov_blanket(e)
        end
      end

      # normalize results
      magnitude = 0
      returnval = {}
      state_frequencies.each_value {|count| magnitude += count }
      state_frequencies.each {|state, count| returnval[state] = count / magnitude.to_f }
      returnval
    end

  private
    def relevant_evidence(nodename, evidence)
      returnval = {}
      evidence.each do |name, state|
        next if @evidence.has_key?(name)
        # next if @nodes[nodename].is_explained_away?(@nodes[name], @evidence)
        returnval[name] = state
      end
      returnval
    end

    # Returns an event in which nodes that are not fixed by the evidence are set
    # to random states whose frequencies (after repeated calls) are consistent
    # with the network's joint probability distribution.
    def generate_random_event
      unset_nodes = @nodes.reject {|name, node| @evidence.has_key? name }
      new_evidence = @evidence.dup
      until unset_nodes.empty? do
        settable_nodes = unset_nodes.reject {|name, node| !node.can_be_evaluated?(new_evidence) }
        settable_nodes.each do |name, node|
          unset_nodes.delete(name)
          new_evidence[name] = node.get_random_state(new_evidence)
        end
      end
      new_evidence
    end
  end
end    