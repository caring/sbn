class Sbn
  enums %w(INFERENCE_MODE_VARIABLE_ELIMINATION,
           INFERENCE_MODE_MARKOV_CHAIN_MONTE_CARLO)
  
  MCMC_NUM_SAMPLES = 2000
  
  class Net
    attr_reader :name, :nodes
    
    def initialize(name = '')
      @@net_count ||= 0
      @@net_count += 1
      @name = (name.empty? ? "net_#{@@net_count}" : name.to_underscore_sym)
      @nodes = {}
      @evidence = {}
    end
    
    def add_node(node)
      @nodes[node.name] = node
    end
    
    def ==(net)
      returnval = true
      returnval = false unless net.name == @name
      returnval = false unless @nodes.keys.map {|k| k.to_s}.sort == net.nodes.keys.map {|k| k.to_s}.sort
      net.nodes.each do |name, node|
        if @nodes.has_key? name
          parent_names = []
          node.parents.each {|p| parent_names << p.name.to_s }
          my_parent_names = []
          @nodes[name].parents.each {|p| my_parent_names << p.name.to_s }
          returnval = false unless parent_names.sort == my_parent_names.sort
          table = node.probability_table.transpose.last
          my_table = @nodes[name].probability_table.transpose.last
          returnval = false unless table == my_table          
        else
          returnval = false
        end
      end
      returnval
    end
    
    def <<(obj)
      if obj.is_a? Array
        obj.each {|n| add_node(n) }
      else
        add_node(obj)
      end
    end
    
    def set_evidence(event)
      @evidence = event.symbolize_keys_and_values
    end

  	# Returns the estimated posterior probability for the specified node based
  	# on previously-supplied evidence, using the Markov Chain Monte Carlo
  	# algorithm.  The MCMC algorithm generates each event by making a random
  	# change to the preceding event.  The next state is generated by randomly
  	# sampling a value for one of the nonevidence variables Xi, conditioned on
  	# the current values of the variables in the Markov blanket of Xi.  MCMC
  	# basically wanders randomly around the state space--the space of possible
  	# complete assignments--flipping one variable at a time, but keeping the
  	# evidence variables fixed.  The sampling process works because it settles
  	# into a "dynamic equilibrium" in which the long-run fraction of time spent
  	# in each state is proportional to its posterior probability.
    def query_node(nodename)
      state_frequencies = {}
      e = generate_random_event
      relevant_e = relevant_evidence(nodename, e)
      MCMC_NUM_SAMPLES.times do
        state = e[nodename]
        state_frequencies[state] ||= 0
        state_frequencies[state] += 1
        
        relevant_e.each do |nname, nstate|
          e[nname] = @nodes[nname].get_random_state_with_markov_blanket(e)
        end
      end
      
      # normalize results
      magnitude = 0
      returnval = {}
      state_frequencies.each_value {|count| magnitude += count }
      state_frequencies.each {|state, count| returnval[state] = count / magnitude.to_f }
      returnval
    end
    
    # converts net to XMLBIF format
    # (http://www.cs.cmu.edu/afs/cs/user/fgcozman/www/Research/InterchangeFormat/)
    def to_xmlbif
      xml = Builder::XmlMarkup.new(:indent => 2)
      xml.instruct!
      xml.comment! <<-EOS
      
        Bayesian network in XMLBIF v0.3 (BayesNet Interchange Format)
        Produced by SBN4R (Simple Bayesian Network library for Ruby)
        Output created #{Time.now}
      EOS
      xml.text! "\n"
      xml.comment! "DTD for the XMLBIF 0.3 format"
      xml.declare! :DOCTYPE, :bif do
        xml.declare! :ELEMENT, :bif, :"(network)*"
        xml.declare! :ATTLIST, :bif, :version, :CDATA, :"#REQUIRED"
        xml.declare! :ELEMENT, :"network (name, (property | variable | definition)*)"
        xml.declare! :ELEMENT, :name, :"(#PCDATA)"
        xml.declare! :ELEMENT, :"variable (name, (outcome | property)*)"
        xml.declare! :ATTLIST, :"variable type (nature | decision | utility) \"nature\""
        xml.declare! :ELEMENT, :outcome, :"(#PCDATA)"
        xml.declare! :ELEMENT, :definition, :"(for | given | table | property)*"
        xml.declare! :ELEMENT, :for, :"(#PCDATA)"
        xml.declare! :ELEMENT, :given, :"(#PCDATA)"
        xml.declare! :ELEMENT, :table, :"(#PCDATA)"
        xml.declare! :ELEMENT, :property, :"(#PCDATA)"
      end
      xml.bif :version => 0.3 do
        xml.network do
          xml.name(@name.to_s.titleize)
          xml.text! "\n"
          xml.comment! "Variables"
          @nodes.each do |name, node|
            xml.variable(:type => "nature") do
              xml.name(name.to_s.titleize)
              node.states.each {|s| xml.outcome(s.to_s) }
            end
          end
          xml.text! "\n"
          xml.comment! "Probability distributions"
          @nodes.each do |name, node|
            xml.definition do
              xml.for(name.to_s.titleize)
              node.parents.each {|parent| xml.given(parent.name.to_s.titleize) }
              xml.table(node.probability_table.transpose.last.join(' '))
            end
          end
        end
      end
    end
    
    def self.from_xmlbif(source)
      # convert tags to lower case
      source.gsub!(/(<.*?>)/, '\\1'.downcase)
      
      doc = XmlSimple.xml_in(source)
      netname = doc['network'].first['name'].first
            
      # find net name
      returnval = Net.new(netname)
      
      # find nodes
      nodes = {}
      node_elements = doc['network'].first['variable'].each do |var|
        nodename = var['name'].first
        states = var['outcome']
        table = nil
        doc['network'].first['definition'].each do |defn|
          if defn['for'].first == nodename
            table = defn['table'].first.split.map {|prob| prob.to_f }
          end
        end
        nodes[nodename] = Node.new(nodename, states, table)
      end

      # find relationships between nodes
      doc['network'].first['definition'].each do |defn|
        nodename = defn['for'].first
        parents = defn['given']
        parents.each {|p| nodes[nodename].add_parent(nodes[p]) } if parents
      end
      returnval << nodes.values
      returnval
    end
    
  private
    def relevant_evidence(nodename, evidence)
      returnval = {}
      evidence.each do |name, state|
        next if @evidence.has_key?(name)
        next unless @nodes[nodename].is_explained_away?(@nodes[name], evidence)
        returnval[name] = state
      end
      returnval
    end
  
    # Returns an event in which nodes that are not fixed by the evidence are set
    # to random states whose frequencies (after repeated calls) are consistent
    # with the network's joint probability distribution.
    def generate_random_event
      returnval = @evidence.dup
      @nodes.each do |name, node|
        next if @evidence.has_key?(name)
        returnval[name] = node.get_random_state(returnval) if node.can_be_evaluated?(returnval)
      end
      returnval
    end
  end
end
